\section{Renderin pipeline}
\label{sec:opengl_rendering_pipeline}
Now dat we know what tha fuck a VBO is, we is locked n loaded ta render tha objects busted lyrics bout by a set of VBOs on tha screen. I aint talkin' bout chicken n' gravy biatch. First we activate tha data we wanna render by spittin some lyrics ta tha graphics card (of course by rockin tha OpenGL API) which VBO identifier represents tha positions, colors, aiiight vectors n' texture coordinates. Then, we ask tha GPU ta render tha activated data as tha primitizzle tha vertices represent (we know if tha vertices should be rendered as triangles, quadz or lines).

We can now make full use of tha parallel architecture of tha GPU. On a high end NVIDIA graphics card\footnote{Such as tha NVIDIA GTX Titan. I aint talkin' bout chicken n' gravy biatch fo' realz. At tha time of writing, it costs bout 8000 NOK on \url{http://www.komplett.no}.}, there be often mo' than 2000 cores available ta run lil' small-ass programs called \textit{shaders} dat process tha input data from vertices ta tha final image rendered on tha screen. I aint talkin' bout chicken n' gravy biatch. Da shadaz is freestyled up in a programmin language called GLSL\footnote{GLSL (OpenGL Shadin Language) be a programmin language wit syntax similar ta C. Well shiiiit, it serves up a set of linear algebra operations dat is heavily used up in computer graphics.} n' is compiled on tha GPU runtime. Da full thang of processin all tha vertices calculatin tha final color joints fo' all tha pixels is distributed on these cores. In dis section our phat asses say shit bout tha different renderin steps up in whatz called tha \textit{renderin pipeline} dat is relevant ta pimp tha visualization tools up in dis thesis. In figure \ref{fig:opengl_rendering_pipeline} our crazy asses have illustrated tha renderin pipeline containin tha stages dat our crazy asses have used. Y'all KNOW dat shit, muthafucka! 
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, trim=0cm 0cm 0cm 0cm, clip]{opengl/figures/pipeline.png}
\end{center}
\caption{Diagram of tha OpenGL renderin pipeline. Da gray boxes is shader steps (the shader programs can be freestyled by tha user). Each vertex is processed up in tha vertex shader before it is busted ta tha geometry shader dat can create zero or mo' vertices based on tha input vertex. Each vertex is then analyzed up in tha clippin program dat removes vertices dat cannot be rendered. Y'all KNOW dat shit, muthafucka! Da rasterization program creates a two dimensionizzle image of every last muthafuckin triangle so dat tha fragment shader can merge every last muthafuckin thang ta color joints per pixel on tha screen. I aint talkin' bout chicken n' gravy biatch. Not dat tha full pipeline gotz nuff mo' steps yo, but these is tha relevant stages fo' understandin what tha fuck our visualization tool do.}
\label{fig:opengl_rendering_pipeline}
\end{figure}
\subsection{Ins, outs n' uniforms}
\label{sec:opengl_uniforms}
As our crazy asses have already mentioned, tha shadaz is lil' small-ass programs run up in parallel. Each shader gets some input data which is called \textit{input}-variables. These is specific joints fo' dis \textit{instance} of tha shader, fo' example tha posizzle vertex fo' a particle. Da shader then probably calculates \textit{something} (a common task up in tha straight-up original gangsta shader stage is ta convert a vertex from tha model space ta tha projection space), before it sendz a variable ta tha next step up in tha pipeline. Da variablez goin outta a shader iz of course called a \textit{output}-variable. Just ta be shizzle we understand; tha next shader gets dis \textit{output}-variable as a \textit{input}-variable fo' further processing.

But there be of course some variablez dat is constant all up in tha whole renderin process. If all tha particlez have tha same color, our phat asses don't need ta specify tha color per atom (this would bust a shitload of extra bandwidth on tha GPU). Variablez like dis should be busted ta tha GPU as so-called \textit{uniform}-variables. They is available up in all instancez of every last muthafuckin shader stage.

\subsection{Vertex shader}
Da vertex shader is executed once per vertex up in tha input VBOs. Well shiiiit, it specifies which input vertex dat is ta be interpreted as tha position, color, aiiight vector and/or texture coordinizzle if they is specified. Y'all KNOW dat shit, muthafucka! Da input posizzle vertex is probably up in tha model space which is local coordinates fo' dis specific object fo' realz. A typical vertex shader applies tha Model View Projection matrix on tha vertex, transformin it from tha model space ta tha projection space which often be assumed up in tha later pipeline stages. Da latter may be done on tha geometry shader instead if a three dimensionizzle object is pimped at dat stage.

\subsection{Geometry shader}
Each vertex from tha vertex shader be a part of a primitizzle (like fuckin \textit{GL\_POINTS} or \textit{GL\_TRIANGLES}) fo' realz. A geometry shader takes a primitizzle (i.e. a set of vertices, each processed by tha vertex shader) as input n' outputs zero or mo' primitives dat may be of another type than tha input primitizzle fo' realz. A typical use is ta describe a geometrical object (this could be a sphere or a tube) on tha geometry shader so dat tha input primitizzle is just one single vertex; tha position. I aint talkin' bout chicken n' gravy biatch. This hella reduces tha memory n' bandwidth usage on tha GPU which probably gives pimped out performizzle improvements.

Da geometry shader can also be run up in \textit{instancin mode} which means dat tha shader program is run a given number of time per vertex wit a invocation id given. I aint talkin' bout chicken n' gravy biatch. If a particle system obeys periodic boundary conditions, we can fo' example use tha geometry shader instancin ta add 26 periodic copiez of tha system makin tha system look larger than it is. 

\subsection{Clipping}
After tha geometry shader has decided which primitives we want rendered, a shitload of tha vertices may not be visible on tha screen. I aint talkin' bout chicken n' gravy biatch. They can be behind tha camera, too far ta tha right or up in some way outside tha camera view. When we up in tha final stages (the fragment shader) is goin ta decizzle flavas on every last muthafuckin pixels, our phat asses don't need ta compute primitives dat do not contribute ta tha final image. This is called clippin n' be a straight-up simple process ta big-ass up in tha projection space fo' realz. All vertices outside tha clip volume (the volume dat is ghon be rendered) is ghon be discarded n' not computed all up in tha rasterization stage.
\subsection{Rasterization}
Da rasterization program will fo' each primitizzle determine which pixels dat is a part of tha primitive. Each actizzle pixel gonna git interpolated flavas n' texture coordinates as busted lyrics bout up in subsection \ref{sec:opengl_texture_interpolation} before we reach tha fragment shader, tha final stage up in tha renderin pipeline.
\subsection{Fragment shader}
Da fragment shader is executed one time \textit{per pixel} fo' each of tha primitives dat contributes ta dat pixel. If tha primitives is transparent, tha final color value on a pixel is ghon be a cold-ass lil combination of all tha primitives. Da fragment shader gets interpolated color joints n' texture coordinates (like we explained up in section \ref{sec:opengl_color_interpolation}) dat is used ta decizzle tha actual color of dat pixel. This is tha last step we cover up in tha OpenGL pipeline. Da final color joints is then freestyled ta a \textit{framebuffer} which finally is tha image dat is shown on tha screen on tha computer.