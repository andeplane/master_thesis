With our newly acquired knowledge about OpenGL and learned how we can use the API to render objects on the screen, we have everything we need to develop our own visualization tools that can handle datasets from both MD and DSMC. As we now should be well aware of, the state of a system with $N$ particles is described by the $3N$ particle positions and the $3N$ velocity components. If we save this information every timestep of a simulation, we can use it to render a time series, an animation of the trajectories of all the particles. We will render the particles as spheres, but areg oing to cheat a bit. An actual sphere rendered in OpenGL would need to be composed of many triangles forming the spherical shape. To be able to render a smooth sphere, we would need more than 100 triangles \textit{per sphere} as we will see in section \ref{sec:vis_billboards}. We will apply a trick used in computer games for years. Instead of rendering spheres, we use something called \textit{billboards}, which is a rectangle with an \textit{image} (a texture) of a sphere, always pointing towards the camera. In section \ref{sec:vis_billboards}, we explain how we effectively can create and render billboards with the goemetry shader on the GPU. If the particle system has periodic symmetry (both MD and DSMC use periodic boundary conditions), we can also use the geometry shader to render copies of the system, making the illusion that the system is larger than it really is.\\
When we visualize a dataset from a DSMC simulation, we should, in addition to the particle positions, render the surface geometry (which, as we remember from section \ref{sec:dsmc_complex_geometries}, is a voxelized scalar field). We will then be able to see the surface the particles collide with which will make it easier to understand their behavior. In section \ref{sec:marching_cubes}, we discuss the so-called \textit{marching cubes} algorithm, which allows us to create a set of renderable triangles from the isosurface of a scalar field (the points where the scalar field values intersect some value).\\
We conclude the chapter by explaining how such a program was extended to render 3D images on an Oculus Rift\footnote{The Oculus Rift is a virtual reality headset displaying a stereoscopic rendering giving realistic 3D effects. The Rift has head tracking, allowing the user to tilt and rotate the head so he/she can look around in the virtual world.} in section \ref{sec:oculus_rift}. The same rendering technique was used to visualize the particles in 3D on a 3D TV.