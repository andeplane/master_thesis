Whenever scientists perform an experiment in the lab or on a computer, they need to study the information outcome of the experiment. This could be the positions of some particles, the temperature of a gas or maybe the color of a fluid. Once we have this information, we need to represent it in a way that is useful for understanding the results. We often put numbers in a table or plot them as a graph. This is an extremely powerful ways to look at data and we can learn a lot by seeing how two or more variables are dependent of each other. It is convenient to introduce a general term, \textit{visualization}, which is just a visual representation of information (maybe not \textit{any} visual representation. Numbers in a table might be excluded.) One could say that a world map is a representation of the geometrical information describing how the continents are connected. The graph of some data is a relation between two or more variables. The output result from any computer simulation or experiment is information that can be visualized in some way.

There already exists a lot of software that can be used to visualize data in different ways. For particle simulations one can for example use \textit{VMD}\footnote{\url{http://www.ks.uiuc.edu/Research/vmd/}} or \textit{Ovito}\footnote{\url{http://www.ovito.org/}}. Both of these are great tools allowing us to visualize the time trajectories of atoms or particles. There are two drawbacks that have motivated the author to write a visualization tool from scratch.

In both VMD and Ovito, the way we navigate with the camera is inspired by other 3d software like 3ds Max, Maya and Blender where the camera is pointing towards a point whereas the mouse controls the position of the camera on the surface of a sphere centered in point. If we want to follow the movement of a single particle, this way of controlling the camera is inconvenient. We would like to control the camera in the way a space ship is controlled in a game, like in a first person shooter game. Here the mouse controls the direction the camera is looking and the camera position is controlled by the keyboard.

In addition, there are performance drawbacks with both programs where we have noticed that medium sized datasets (number of particles $\approx 1\e{6}$) lead to a frame rate that makes it very difficult to navigate around in the system. Also, the geometry of the DSMC code cannot be visualized in VMD or Ovito since these are particle visualizers only and the geometry is represented as a scalar field (the voxels from section \ref{sec:dsmc_complex_geometries}). To be able to solve these problems, we have implemented our own visualizer using OpenGL. In this chapter, we first give a brief introduction to OpenGL in section \ref{sec:opengl} explaining its basic ideas. We go through the concepts of vertices, primitives and how colors and textures are linearly interpolated from the values of the vertices. In section \ref{sec:opengl_coordinate_transformations} we discuss the three different coordinate spaces (model space, view space and projection space) that are used in the rendering. Vertex Buffer Objects are briefly explained in section \ref{sec:opengl_vbo} before we go through the sequence of shaders in the rendering pipeline in section \ref{sec:opengl_rendering_pipeline}. Note that this is not a complete introduction of OpenGL. Only the basic concepts that are required to understand how we have made the visualization tools are covered.