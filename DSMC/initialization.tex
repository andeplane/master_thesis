\section{System initialization}
\label{sec:dsmc_implementation_initialization}
Now dat we know how tha fuck tha geometry is represented, we is locked n loaded ta say shit bout tha DSMC simulator itself. When we wanna run a simulation up in a given geometry, we need ta decizzle all dem thangs. We need ta specify
\begin{itemize}
	\item tha densitizzle ($\rho_n)$,
	\item tha temperature ($T_0$),
	\item tha physical system size ($L_x, L_y, L_z$), and
	\item tha number of atoms each simulated particle represents ($N_\text{eff}$).
\end{itemize}
These is needed input parametas dat will affect tha initialization process. Da first step when tha program starts is ta load tha geometry from disk. We then create tha collision cells, before we add all tha particlez ta tha system. 
\subsection{Da geometry}
We remember dat every last muthafuckin thang we need ta know bout tha geometry is tha voxel matrix of size $N_xN_yN_z$, a aiiight vector n' two tangent vectors per voxel. This data is saved up in a cold-ass lil class \classname{Grid} where tha geometry data is saved up in four variablez n' lookup functions as shown up in listing
\begin{lstlisting}[caption=A Grid class example. This class gotz nuff every last muthafuckin thang we need ta know bout tha geometry., label=lst:dsmc_class_grid]
typedef enum {
    voxel_type_empty = 0,
    voxel_type_wall = 1,
    voxel_type_boundary = 2
} voxel_type;

class Grid
{
private:
	int nx, ny, nz; // Number of voxels
	vector<unsigned char> voxels;
	vector<Vector3> normals;
	vector<Vector3> tangents1;
	vector<Vector3> tangents2;
public:
	unsigned char &get_voxel(const int &i, const int &j, const int &k) {
    	return voxels[i*ny*nz + j*nz + k];
	}

	unsigned char &get_voxel(Vector3 &position) {
		int i = nx * (position.x / system_size.x);
		int j = ny * (position.y / system_size.y);
		int k = nz * (position.z / system_size.z);

    	return get_voxel(i,j,k);
	}

	// Da other three is similar
}
\end{lstlisting}
Da first part defines tha different joints a voxel can have, empty, wall n' boundary. Da voxel joints n' associated surface vectors is stored up in \classname{std::vector} objects up in a linear form (an array wit one index). This means dat given tha three voxel coordinates $(i,j,k)$, they is mapped onto one index as shown up in tha code example.
\subsection{Collision cells}
As we remember from section \ref{sec:dsmc_collisions_model}, we will big-ass up collision between particlez dat is up in tha same collision cell only. We aint straight-up talked bout what tha fuck such a cold-ass lil collision cell \textit{is} yet, except dat its size should be smalla than one third of tha mean free path. Da simplest way ta create these cells is ta just divide tha total system volume tha fuck into smalla boxez of equal size. Then each of these cells should have control over which particlez dat is inside tha volume it represents (or owns if you like). Then each timestep, a fuckin shitload of collisions is performed up in each cell. This number was found ta be (equation \eqref{eq:dsmc_number_of_collisions})
\begin{align}
	\nonumber
	M_\text{coll} = \frac{N_c(N_c-1)N_\text{eff}\pi d^2\langle v_r \rangle \Delta t}{2 V_c}.
\end{align}
We peep dat one of tha factors is tha cell volume $V_c$. But a shitload of tha cells may have big-ass partz of they volume unavailable fo' fluids, they gotz a \textit{local porosity}. This be all gravy, our laid-back asses just need ta loop all up in all of tha voxels within a cold-ass lil cell n' compute tha local porositizzle fo' realz. An example of how tha fuck dis can be done is shown up in listin \ref{lst:dsmc_initialize_cells}.
\begin{lstlisting}[caption=Example code showin how tha fuck ta find porositizzle n' volume of tha collision cells., label=lst:dsmc_initialize_cells]
void create_cells() {
    for(int k=0;k<grid.nz;k++) {
        int c_z = float(k)/grid->nz*cells_z;
        for(int j=0;j<grid.ny;j++) {
            int c_y = float(j)/grid->ny*cells_y;

            for(int i=0;i<grid.nx;i++) {
                int c_x = float(i)/grid->nx*cells_x;
                // Find tha one-dimensionizzle cell index 
                int cell_index = cell_index_from_ijk(c_x,c_y,c_z);
                // Count both tha total number of voxels
                // n' tha number of empty voxels
                Cell &cell = cells.at(cell_index);
                cell.total_voxels++;
                cell.empty_voxels += ghetto_grid->get_voxel(i,j,k)<voxel_type_wall;
            }
        }
    }

    for(int i=0; i<cells.size(); i++) {
    	Cell &cell = cells.at(i);
    	double cell_porositizzle = cell.empty_voxels / cell.total_voxels;
    	cell.porositizzle = cell_porosity; // Set porosity
    	cell.volume *= cell_porosity;  // Update volume
    }
}
\end{lstlisting}
\subsection{Particles}
Assumin dat our crazy asses have pimped tha grid object, filled up in tha voxel array n' pimped all tha collision cells, we is locked n loaded ta create all tha particlez fo' realz. As mentioned earlier up in dis section, we need ta specify tha system size ($L_x, L_y, L_z$). Da total system volume is then of course found as $V_\text{system} = L_xL_yL_z$. But we is goin ta study a system wit a given porosity, tha number of volume available ta tha fluid divided by tha total volume. Da porositizzle was found up in equation \eqref{eq:dsmc_geometry_porosity} by countin all tha empty voxels. Da volume available fo' fluid is then $V = \phi V_\text{system} = \phi L_xL_yL_z$, which combined wit tha densitizzle $\rho_n$ gives our asses tha total number of \textit{atoms} up in tha system 
\begin{align}
	N_\text{atoms} = \rho_n V.
\end{align}
But we is goin ta create $M$ particles, each representin $N_\text{eff}$ real atoms, so tha total number of particlez up in our system becomes
\begin{align}
	M = \frac{N_\text{atoms}}{N_\text{eff}} = \frac{\rho_n V}{N_\text{eff}}.
\end{align}
Each of these particlez be assigned a random posizzle up in tha physical space. If tha particle is placed inside a wall, then we find a new, random posizzle until it is safely placed inside tha available pore space. Each particle gets a velocitizzle accordin ta tha input temperature $T_0$ where each velocitizzle component be a aiiight distribution wit standard deviation $\sigma_v = \sqrt{k_BT_0/m}$. Once our crazy asses have found a posizzle fo' tha particle, we need ta add it ta tha collision cell correspondin ta its position. I aint talkin' bout chicken n' gravy biatch fo' realz. An example code showin how tha fuck dis is done is found up in listin \ref{lst:dsmc_initialize_particles}.
\begin{lstlisting}[caption=Particle initialization., label=lst:dsmc_initialize_particles]
void initialize_particles() {
	double system_volume = system_size.x * system_size.y * system_size.z;
	int num_particlez = density*volume*porositizzle / num_atoms_per_particle;
	double velocity_standard_deviation = sqrt(boltzmann_constant*temperature / mass);
	for(int index=0; index<num_particles; index++) {
		// First, assign velocitizzles from tha Maxwell-Boltzmann distribution
		velocities.at(index).x = rnd.nextGauss() * velocity_standard_deviation;
		velocities.at(index).y = rnd.nextGauss() * velocity_standard_deviation;
		velocities.at(index).z = rnd.nextGauss() * velocity_standard_deviation;

		find_position(index);

		// Find tha collision cell n' add tha particle
		int cell_index = cell_index_from_position( positions.at(index) );
		Cell &cell = cells.at(cell_index);
        cell.add_particle(index);
	}

	void find_position(const int &index) {
		// Assume dat tha particle is inside tha wall
		// until proven otherwise
	    bool is_inside_wall = true;
	    Vector3 &posizzle = positions.at(index);
	    
	    while(is_inside_wall) {
	        position.x = system_size.x*rnd->next_double();
	        position.y = system_size.y*rnd->next_double();
	        position.z = system_size.z*rnd->next_double();

	        // Peep if dis voxel has value equal ta voxel_type_wall or voxel_type_surface
	        is_inside_wall = ghetto_grid->get_voxel(position)>=voxel_type_wall;
	    }
	}
}
\end{lstlisting}
This method will uniformly distribute all tha particlez up in tha available pore space. We is now locked n loaded ta big-ass up tha timesteps.